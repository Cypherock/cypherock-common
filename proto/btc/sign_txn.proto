syntax = "proto3";

import "common.proto";
import "error.proto";

package btc;

/**
 * Example where there are 3 inputs and 2 outputs in the txn
 *
 *        Host                       Device
 *
 * SignTxnInitiateRequest  => 
 *                         <= SignTxnConfirmationResponse
 * SignTxnMetadata         =>
 *                         <= SignTxnMetadataAccepted
 *
 *
 * SignTxnInput            =>
 *                         <= SignTxnInputAccepted
 * SignTxnInput            =>
 *                         <= SignTxnInputAccepted
 * SignTxnInput            =>
 *                         <= SignTxnInputAccepted
 *
 *
 * **** Previous raw transaction for First (1st) input ****
 *
 * SignTxnRawTxn           =>
 *                         <= SignTxnRawTxnAccepted
 *                        ....
 * SignTxnRawTxn           =>
 *                         <= SignTxnRawTxnAccepted
 *
 * NOTE: The input is complete when ChunkPayload.remaining_size = 0 and
 * ChunkPayload.chunk_index + 1 = ChunkPayload.total_chunks
 *
 *
 * **** Previous raw transaction for Second (2nd) input ****
 *
 * SignTxnRawTxn           =>
 *                         <= SignTxnRawTxnAccepted
 *                        ....
 * SignTxnRawTxn           =>
 *                         <= SignTxnRawTxnAccepted
 *
 *
 * **** Previous raw transaction for Third (3rd) input ****
 *
 * SignTxnRawTxn           =>
 *                         <= SignTxnRawTxnAccepted
 *                        ....
 * SignTxnRawTxn           =>
 *                         <= SignTxnRawTxnAccepted
 *
 *
 * **** Send the output UTXO one at a time ****
 *
 * SignTxnOutput           =>
 *                         <= SignTxnOutputAccepted
 * SignTxnOutput           =>
 *                         <= SignTxnOutputAccepted
 *
 *
 * **** Device has all transaction information ****
 *
 *
 * SignTxnSignatureRequest =>
 *                         <= SignTxnSignatureResponse
 * SignTxnSignatureRequest =>
 *                         <= SignTxnSignatureResponse
 */

enum SignTxnStatus {
  SIGN_TXN_STATUS_INIT = 0;
  SIGN_TXN_STATUS_CONFIRM = 1;
  SIGN_TXN_STATUS_VERIFY = 2;
  SIGN_TXN_STATUS_SEED_GENERATED = 3;
}

message SignTxnInitiateRequest {
  bytes wallet_id = 1;
  repeated uint32 derivation_path = 2;
}

message SignTxnConfirmationResponse {
}

message SignTxnMetadata {
  // transaction output UTXO fields
  uint32 version = 1;
  uint32 input_count = 2;
  uint32 output_count = 3;
  uint32 locktime = 4;
  uint32 sighash = 5;
}

message SignTxnMetadataAccepted {
}

message SignTxnInputAccepted {
}

message SignTxnInput {
  bytes prev_txn_hash = 1;

  uint32 prev_output_index = 2;
  uint64 value = 3;
  bytes script_pub_key = 4;
  uint32 sequence = 5;

  uint32 change_index = 6;
  uint32 address_index = 7;
}

message SignTxnRawTxn {
  common.ChunkPayload chunk_payload = 1;
}

message SignTxnRawTxnAccepted {
  common.ChunkAck chunk_ack = 1;
}

message SignTxnOutputAccepted {
}

message SignTxnOutput {
  // transaction output UTXO fields
  int64 value = 1;
  bytes script_pub_key = 2;

  bool is_change = 3;
  // output change address index that should be checked on the HW device
  optional uint32 changes_index = 4;
}

message SignTxnVerifiedResponse {
}

message SignTxnSignatureRequest {
}

message SignTxnSignatureResponse {
  bytes signature = 1;
}

message SignTxnRequest {
  oneof request {
    SignTxnInitiateRequest initiate = 1;
    SignTxnMetadata meta = 2;
    SignTxnInput input = 3;
    SignTxnRawTxn raw_txn = 4;
    SignTxnOutput output = 5;
    SignTxnSignatureRequest signature = 6;
  }
}

message SignTxnResponse {
  oneof response {
    SignTxnConfirmationResponse confirmation = 1;
    SignTxnMetadataAccepted meta_accepted = 2;
    SignTxnInputAccepted input_accepted = 3;
    SignTxnRawTxnAccepted raw_txn = 4;
    SignTxnOutputAccepted output_accepted = 5;
    SignTxnSignatureResponse signature = 6;

    error.CommonError common_error = 7;
  }
}
